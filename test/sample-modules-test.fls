path: require('path')
fs: require('fs')
process: require('child_process')

func runProcess(command, args, cb, opt)
    p: process.spawn(command, args, opt)
    stdout: []
    stderr: []
    p.stdout.on('data', (data): stdout.push(data))
    p.stderr.on('data', (data): stderr.push(data))
    p.on('close', (code): cb(null, {
        code: code,
        stdout: stdout.join(''),
        stderr: stderr.join(''),
    }))

func runRawProcess(command_str, %%, opt)
    c: command_str.split(' ')
    return runProcess(c[0], c[1,], %%, opt)

func flatsCompile(file, %%)
    r: runRawProcess('./flatsc -e require -i ' + file, %%)
    if r.code != 0
        throw 'Failed to compile ' + file + ': ' + r.stderr
    return r.stdout

func verifyDir(d, %%)
    dir: path.join('samples', 'modules', d)
    fs.readdir(dir, %%) |? $.slice(-4) = '.fls' |:
        fls: path.join(dir, $)
        js: flatsCompile(fls, %%)
        fs.writeFile(fls.slice(0, -4) + '.js', js, %%)

    n: runProcess('node', ['entry.js'], %%, {cwd: dir})
    if n.code != 0
        throw 'Failed to exec module ' + d + ': ' + n.stderr

    actualOutput: path.join(dir, 'tmp.actual.txt')
    fs.writeFile(actualOutput, n.stdout, %%)
    diff: runProcess('diff', [path.join(dir, 'expected.txt'), actualOutput], %%)
    if diff.code != 0
        throw 'Failed to verify module ' + dir + ':\n' + diff.stdout
    console.log(dir, 'module passed.')

try
    [
        'export', 'class',
    ] |: verifyDir($, %%)
catch
    console.error($e)
